#!/usr/bin/env bash
# sciClaw VM manager â€” one-command setup via Multipass.
#
# Usage:
#   deploy/vm start [project-dir]   Create/start VM, sync project directory
#   deploy/vm stop                  Pause the VM (frees RAM, keeps state)
#   deploy/vm status                Show VM state
#   deploy/vm destroy               Delete the VM entirely
#   deploy/vm shell                 Open a terminal in the VM
#   deploy/vm doctor                Run sciclaw doctor inside the VM
#   deploy/vm onboard [args...]     Run sciclaw onboard inside the VM
#   deploy/vm auth [args...]        Run sciclaw auth ... inside the VM
#   deploy/vm channels [args...]    Run sciclaw channels ... inside the VM
#   deploy/vm tui                   Open interactive VM control center
#   deploy/vm push [project-dir]    Sync host â†’ VM
#   deploy/vm pull [project-dir]    Sync VM â†’ host
#
# The first argument to "start" is the host directory to sync into the VM.
# Defaults to the current working directory.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
VM_NAME="sciclaw"
VM_CPUS=4
VM_MEM="8G"
VM_DISK="80G"
VM_IMAGE="24.04"
CLOUD_INIT_TEMPLATE="${SCICLAW_VM_CLOUD_INIT_TEMPLATE:-$SCRIPT_DIR/multipass-cloud-init.yaml}"
TOOLCHAIN_ENV="${SCICLAW_VM_TOOLCHAIN_ENV:-$SCRIPT_DIR/toolchain.env}"
VM_PROJECT="/home/ubuntu/project"
STATE_DIR="${SCICLAW_VM_STATE_DIR:-${XDG_CACHE_HOME:-$HOME/.cache}/sciclaw}"
STATE_PROJECT_FILE="$STATE_DIR/vm-project-path"
VM_CMD_LABEL="${SCICLAW_VM_CMD_LABEL:-deploy/vm}"

# â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

die()  { echo "error: $*" >&2; exit 1; }
info() { echo "  $*"; }

check_multipass() {
  if ! command -v multipass &>/dev/null; then
    echo "Multipass is not installed."
    echo ""
    echo "Install it (free) from: https://multipass.run"
    echo ""
    echo "  macOS:   brew install multipass"
    echo "  Linux:   sudo snap install multipass"
    echo "  Windows: download from https://multipass.run/install"
    exit 1
  fi
}

vm_state() {
  local state
  state="$(multipass info "$VM_NAME" 2>/dev/null | awk -F': *' '/^State:/{print $2; exit}')" || state=""
  if [ -z "$state" ]; then
    echo "NotFound"
  else
    echo "$state"
  fi
}

resolve_project() {
  local dir="${1:-$(pwd)}"
  cd "$dir" && pwd
}

render_cloud_init() {
  [ -f "$CLOUD_INIT_TEMPLATE" ] || die "cloud-init template not found: $CLOUD_INIT_TEMPLATE"
  [ -f "$TOOLCHAIN_ENV" ] || die "toolchain config not found: $TOOLCHAIN_ENV"

  local rendered
  rendered="$(mktemp /tmp/sciclaw-cloud-init.XXXXXX.yaml)"

  awk -v toolchain="$TOOLCHAIN_ENV" '
    /^[[:space:]]*__TOOLCHAIN_ENV_CONTENT__[[:space:]]*$/ {
      found = 1
      while ((getline line < toolchain) > 0) {
        print "      " line
      }
      close(toolchain)
      next
    }
    { print }
    END {
      if (!found) {
        exit 97
      }
    }
  ' "$CLOUD_INIT_TEMPLATE" > "$rendered" || {
    rm -f "$rendered"
    die "failed to render cloud-init template"
  }

  echo "$rendered"
}

# Sync files host â†’ VM via tarball + multipass transfer (fast, cross-platform)
sync_to_vm() {
  local project_dir="$1"
  local project_name
  project_name=$(basename "$project_dir")
  local tmp_tar="/tmp/.sciclaw-sync.tar.gz"

  info "Syncing $project_name â†’ VM..."

  # Create compressed tarball on host (exclude heavy build artifacts)
  tar czf "$tmp_tar" \
    --exclude='.git' \
    --exclude='.worktrees' \
    --exclude='build' \
    --exclude='vendor' \
    --exclude='node_modules' \
    --exclude='__pycache__' \
    --exclude='.venv' \
    -C "$project_dir" . 2>/dev/null

  # Transfer and extract inside VM
  multipass transfer "$tmp_tar" "$VM_NAME:/tmp/.sciclaw-sync.tar.gz"
  multipass exec "$VM_NAME" -- bash -c \
    "mkdir -p \"$VM_PROJECT\" && tar xzf /tmp/.sciclaw-sync.tar.gz -C \"$VM_PROJECT\" 2>/dev/null; rm -f /tmp/.sciclaw-sync.tar.gz"

  rm -f "$tmp_tar"
  info "Synced to VM:$VM_PROJECT"
}

# Sync files VM â†’ host via tarball + multipass transfer
sync_from_vm() {
  local project_dir="$1"
  local tmp_tar="/tmp/.sciclaw-sync.tar.gz"

  info "Syncing VM â†’ $project_dir..."

  multipass exec "$VM_NAME" -- bash -c \
    "tar czf /tmp/.sciclaw-sync.tar.gz -C \"$VM_PROJECT\" . 2>/dev/null"
  multipass transfer "$VM_NAME:/tmp/.sciclaw-sync.tar.gz" "$tmp_tar"
  tar xzf "$tmp_tar" -C "$project_dir" 2>/dev/null
  multipass exec "$VM_NAME" -- rm -f /tmp/.sciclaw-sync.tar.gz

  rm -f "$tmp_tar"
  info "Synced from VM:$VM_PROJECT"
}

# â”€â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_start() {
  local project_dir
  project_dir=$(resolve_project "${1:-}")

  if [ ! -d "$project_dir" ]; then
    die "directory not found: $project_dir"
  fi

  local state
  state=$(vm_state)

  case "$state" in
    Running)
      info "VM already running."
      ;;
    Stopped|Suspended)
      echo "Starting VM..."
      multipass start "$VM_NAME"
      info "VM started."
      ;;
    NotFound)
      local rendered_cloud_init
      rendered_cloud_init="$(render_cloud_init)"
      echo "Creating sciClaw VM (this takes a few minutes on first run)..."
      echo ""
      multipass launch \
        --name "$VM_NAME" \
        --cpus "$VM_CPUS" \
        --memory "$VM_MEM" \
        --disk "$VM_DISK" \
        --cloud-init "$rendered_cloud_init" \
        "$VM_IMAGE"
      rm -f "$rendered_cloud_init"
      echo ""
      info "VM created. Waiting for tools to install..."
      local cloud_init_output cloud_init_rc
      set +e
      cloud_init_output="$(multipass exec "$VM_NAME" -- cloud-init status --wait 2>&1)"
      cloud_init_rc=$?
      set -e
      printf '%s\n' "$cloud_init_output"
      if [ "$cloud_init_rc" -ne 0 ]; then
        if printf '%s\n' "$cloud_init_output" | grep -q '^status:[[:space:]]*done$'; then
          info "cloud-init reported non-zero status but provisioning reached 'done'; continuing."
        else
          echo "cloud-init failed. Recent cloud-init output follows:" >&2
          multipass exec "$VM_NAME" -- bash -lc "sudo tail -n 120 /var/log/cloud-init-output.log" || true
          die "cloud-init did not finish successfully"
        fi
      fi
      info "VM ready."
      ;;
    *)
      die "unexpected VM state: $state"
      ;;
  esac

  # Sync project files into the VM
  sync_to_vm "$project_dir"

  # Save project path so push/pull know where to sync
  mkdir -p "$STATE_DIR"
  echo "$project_dir" > "$STATE_PROJECT_FILE"

  echo ""
  echo "Ready. Your project is at $VM_PROJECT inside the VM."
  echo ""
  echo "  $VM_CMD_LABEL shell     Open a terminal in the VM"
  echo "  $VM_CMD_LABEL push      Sync your local changes â†’ VM"
  echo "  $VM_CMD_LABEL pull      Sync VM changes â†’ local"
  echo "  $VM_CMD_LABEL doctor    Check that all tools are installed"
  echo "  $VM_CMD_LABEL stop      Pause the VM"
}

cmd_push() {
  local project_dir
  if [ -n "${1:-}" ]; then
    project_dir=$(resolve_project "$1")
  elif [ -f "$STATE_PROJECT_FILE" ]; then
    project_dir=$(cat "$STATE_PROJECT_FILE")
  else
    project_dir=$(pwd)
  fi
  sync_to_vm "$project_dir"
}

cmd_pull() {
  local project_dir
  if [ -n "${1:-}" ]; then
    project_dir=$(resolve_project "$1")
  elif [ -f "$STATE_PROJECT_FILE" ]; then
    project_dir=$(cat "$STATE_PROJECT_FILE")
  else
    project_dir=$(pwd)
  fi
  sync_from_vm "$project_dir"
}

cmd_stop() {
  local state
  state=$(vm_state)
  if [ "$state" = "Running" ]; then
    multipass stop "$VM_NAME"
    info "VM stopped."
  elif [ "$state" = "NotFound" ]; then
    die "no VM found. Run '$VM_CMD_LABEL start' first."
  else
    info "VM is already $state."
  fi
}

cmd_status() {
  local state
  state=$(vm_state)
  if [ "$state" = "NotFound" ]; then
    echo "No sciClaw VM found. Run '$VM_CMD_LABEL start' to create one."
    return
  fi
  multipass info "$VM_NAME"
  if [ -f "$STATE_PROJECT_FILE" ]; then
    echo ""
    echo "Project: $(cat "$STATE_PROJECT_FILE") â†” VM:$VM_PROJECT"
  fi
}

cmd_destroy() {
  local state
  state=$(vm_state)
  if [ "$state" = "NotFound" ]; then
    info "No VM to destroy."
    return
  fi
  echo "This will permanently delete the sciClaw VM and all data inside it."
  read -rp "Are you sure? [y/N] " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    multipass delete "$VM_NAME" && multipass purge
    rm -f "$STATE_PROJECT_FILE"
    info "VM destroyed."
  else
    info "Cancelled."
  fi
}

cmd_shell() {
  local state
  state=$(vm_state)
  if [ "$state" != "Running" ]; then
    die "VM is not running. Run '$VM_CMD_LABEL start' first."
  fi
  echo "Entering VM. Your project is at: $VM_PROJECT"
  echo ""
  multipass exec "$VM_NAME" -- bash --login -c "cd \"$VM_PROJECT\" && exec bash"
}

cmd_doctor() {
  local state
  state=$(vm_state)
  if [ "$state" != "Running" ]; then
    die "VM is not running. Run '$VM_CMD_LABEL start' first."
  fi
  multipass exec "$VM_NAME" -- sciclaw doctor
}

require_running() {
  local state
  state=$(vm_state)
  if [ "$state" != "Running" ]; then
    die "VM is not running. Run '$VM_CMD_LABEL start' first."
  fi
}

cmd_sciclaw_passthrough() {
  require_running
  multipass exec "$VM_NAME" -- env HOME=/home/ubuntu sciclaw "$@"
}

default_project_dir() {
  if [ -f "$STATE_PROJECT_FILE" ]; then
    cat "$STATE_PROJECT_FILE"
  else
    pwd
  fi
}

prompt_project_dir() {
  local def input
  def="$(default_project_dir)"
  read -r -p "Project dir [$def]: " input
  if [ -n "${input:-}" ]; then
    echo "$input"
  else
    echo "$def"
  fi
}

pause_screen() {
  echo ""
  read -r -p "Press Enter to continue..." _
}

get_vm_info_field() {
  local field="$1"
  multipass info "$VM_NAME" 2>/dev/null | awk -F': *' -v key="$field" '$1==key {print $2; exit}'
}

get_vm_version_line() {
  multipass exec "$VM_NAME" -- sciclaw --version 2>/dev/null | head -n 1 | sed 's/^ *//'
}

get_vm_channel_lines() {
  multipass exec "$VM_NAME" -- bash -lc '
python3 - <<PY
import json, os
p = os.path.expanduser("~/.picoclaw/config.json")
try:
    cfg = json.load(open(p))
except Exception:
    print("discord: unavailable")
    print("telegram: unavailable")
    raise SystemExit(0)

def line(name, token_key):
    c = cfg.get("channels", {}).get(name, {})
    enabled = bool(c.get("enabled"))
    token = bool(str(c.get(token_key, "")).strip())
    allow = len(c.get("allow_from") or [])
    return f"{name}: enabled={enabled} token={token} allow={allow}"

print(line("discord", "token"))
print(line("telegram", "token"))
PY
' 2>/dev/null || true
}

draw_tui() {
  local state project ip load mem version channels
  state="$(vm_state)"
  project="$(default_project_dir)"
  ip="-"
  load="-"
  mem="-"
  version="-"
  channels=$'discord: unavailable\ntelegram: unavailable'

  if [ "$state" != "NotFound" ]; then
    ip="$(get_vm_info_field "IPv4" | xargs || true)"
    load="$(get_vm_info_field "Load" | xargs || true)"
    mem="$(get_vm_info_field "Memory usage" | xargs || true)"
  fi

  if [ "$state" = "Running" ]; then
    version="$(get_vm_version_line)"
    channels="$(get_vm_channel_lines)"
  fi

  clear
  cat <<EOF
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ðŸ”¬ sciClaw VM Control Center                                                 â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
 VM:      $VM_NAME
 State:   $state
 IP:      ${ip:--}
 Load:    ${load:--}
 Memory:  ${mem:--}
 Project: $project
 Agent:   ${version:--}

 Channels:
   $(printf '%s' "$channels" | sed 's/^/ /')

 Actions:
   [1] Start/Sync VM        [2] Status           [3] Shell
   [4] Onboard              [5] Auth OpenAI      [6] Auth Anthropic
   [7] Discord setup        [8] Telegram setup   [9] Gateway run (foreground)
   [10] Service install     [11] Service start   [12] Service restart
   [13] Service logs        [14] Doctor          [15] Push sync
   [16] Pull sync           [17] Stop VM         [18] Destroy VM
   [q] Quit
EOF
}

run_tui_action() {
  set +e
  "$@"
  local rc=$?
  set -e
  if [ "$rc" -ne 0 ]; then
    echo ""
    echo "Action failed (exit $rc)."
  fi
  pause_screen
}

cmd_tui() {
  while true; do
    draw_tui
    local choice project_dir
    read -r -p "Select action: " choice
    case "${choice:-}" in
      1)
        project_dir="$(prompt_project_dir)"
        run_tui_action cmd_start "$project_dir"
        ;;
      2)  run_tui_action cmd_status ;;
      3)  run_tui_action cmd_shell ;;
      4)  run_tui_action cmd_sciclaw_passthrough onboard ;;
      5)  run_tui_action cmd_sciclaw_passthrough auth login --provider openai ;;
      6)  run_tui_action cmd_sciclaw_passthrough auth login --provider anthropic ;;
      7)  run_tui_action cmd_sciclaw_passthrough channels setup discord ;;
      8)  run_tui_action cmd_sciclaw_passthrough channels setup telegram ;;
      9)  run_tui_action cmd_sciclaw_passthrough gateway ;;
      10) run_tui_action cmd_sciclaw_passthrough service install ;;
      11) run_tui_action cmd_sciclaw_passthrough service start ;;
      12) run_tui_action cmd_sciclaw_passthrough service restart ;;
      13) run_tui_action cmd_sciclaw_passthrough service logs ;;
      14) run_tui_action cmd_doctor ;;
      15)
        project_dir="$(prompt_project_dir)"
        run_tui_action cmd_push "$project_dir"
        ;;
      16)
        project_dir="$(prompt_project_dir)"
        run_tui_action cmd_pull "$project_dir"
        ;;
      17) run_tui_action cmd_stop ;;
      18) run_tui_action cmd_destroy ;;
      q|Q|quit|exit) break ;;
      *)
        echo "Unknown selection: ${choice:-<empty>}"
        pause_screen
        ;;
    esac
  done
}

# â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

check_multipass

case "${1:-help}" in
  start)   cmd_start "${2:-}" ;;
  stop)    cmd_stop ;;
  status)  cmd_status ;;
  destroy) cmd_destroy ;;
  shell)   cmd_shell ;;
  doctor)  cmd_doctor ;;
  onboard) cmd_sciclaw_passthrough onboard "${@:2}" ;;
  auth)    cmd_sciclaw_passthrough auth "${@:2}" ;;
  channels) cmd_sciclaw_passthrough channels "${@:2}" ;;
  tui)     cmd_tui ;;
  push)    cmd_push "${2:-}" ;;
  pull)    cmd_pull "${2:-}" ;;
  help|--help|-h)
    echo "Usage: $VM_CMD_LABEL <command> [options]"
    echo ""
    echo "Commands:"
    echo "  start [dir]   Create/start VM and sync project directory (default: cwd)"
    echo "  stop          Pause the VM"
    echo "  status        Show VM info"
    echo "  destroy       Delete the VM"
    echo "  shell         Open a terminal in the VM (drops you into project dir)"
    echo "  doctor        Check all tools are installed"
    echo "  onboard [...] Run sciclaw onboard inside VM (interactive/idempotent)"
    echo "  auth [...]    Run sciclaw auth ... inside VM"
    echo "  channels [...] Run sciclaw channels ... inside VM"
    echo "  tui           Open interactive VM control center"
    echo "  push [dir]    Sync local changes â†’ VM"
    echo "  pull [dir]    Sync VM changes â†’ local"
    ;;
  *)
    die "unknown command: $1 (try '$VM_CMD_LABEL help')"
    ;;
esac
